---
title: 'useTransform hook'
chapter: 'Motion Values'
order: 110
---

# Transform motion value by useTransform

Framer Motion’s `useTransform()` hook lets you transform one Motion value to a new one, so it’s handy for following a scroll or drag movement. The value it returns doesn’t even have to be numeric. Colors, shadows, gradients, etc., are also possible.

## Using a function

In this motion value example, You give `useTransform()` an arrow function that returns the result, and when using an existing Motion value in the calculation, you add `get()` to obtain its current value. 
<MotionValueSlider />

```js
const leftPanelWidth = useTransform(() => width / 2 + x.get())
const rightPanelWidth = useTransform(() => width / 2 - x.get())
```

## Using input and output ranges

In this example, first make the handle `drag='y'` and set up the `dragConstraints` same length of the line behind. Now the input range is `[0, height - handleHeight]`. `height` is the line height.
the output range is `[0, 20]` (you can change it any number you want). We will get new value from `useTransform` like:

```js
cont newValue = useTransform(y, [0, height - handleHeight], [0, 20])
```

<BasicUseTransform />

### default
The 'default' box on the top shows the default behavior of `useTransform`, which returns newValue only between `0` to `20`, even if you drag outside the drag boundry.

### ease
The 'with ease function' box in the middle, the output value is  the same as default, only between `0` to `20`, but the frequency of how the number changes is diffrent. The way of it works is because adding ease function in the `useTransform`, it will behave like ease in animation. Here is the syntax: 

Using built in ease:
```js
cont newValue = useTransform(y, [0, height - handleHeight], [0, 20], 
    {ease: backIn}
)
```
Using cubic bezier ease:
```js
cont newValue = useTransform(y, [0, height - handleHeight], [0, 20], 
    {ease: cubicBezier(.17,.67,.83,.67)}
)
```

### clamp
The 'clamp disabled' box on the bottom, if you drag outside the `dragConstraints`, it will still return new values based on distance. That's the only diffrence between default and clamp.
In default, the clamp is set to `true` which is omitted.

```js
const newValue = useTransform(y, [0, height - handleHeight], [0, 20], 
    {clamp: false}
)
```

## output format

### multiple ends
The output range is not only limited by 2 numbers like start and end, it could be more than 2 numbers, like `[0, 20, 0]`.
> You can use as many values as you want in the range arrays, but the input and output range should always be the same length.


### Not only numeric values
The input range only accepts numbers, but the output range can be css values, diffrent color format, you have to try it out.

```js
const gradient = useTransform(
    y,
    [0, (height - handleHeight) / 2, height - handleHeight],
    [
        'radial-gradient(circle at 0% 0%, #2C2D29, #42433D)',
        'radial-gradient(circle at 100% 100%, #1C6F59, #52EFCC)',
        'radial-gradient(circle at 0% 0%, #2C2D29, #42433D)',
    ],
    { ease: easeInOut }
)
```

```js
const color = useTransform(
    y,
    [
        0,
        (height - handleHeight) / 3,
        ((height - handleHeight) / 3) * 2,
        height - handleHeight,
    ],
    ['#2C2D29', '#F3B53F', '#8874E3', '#2C2D29']
)
```

<OutputFormat />

## Apple watch dock
This example is originally from [codesandbox ↗](https://codesandbox.io/p/sandbox/6j6l074q9r?file=/src/AppleWatchDock/use-icon-transform.js), but it is in framer motion v1.6, and I try to write it in framer motion v10, and add overflow, duotone options.

The solution changes balls `scale` and `backgroundColor` is calculating the `x` and `y` movements and transform it to new values for `scale` and `backgroundColor`.

The interesting part is how to decide what scale value it should be. There are two scale values generated by `x` and `y`, by `Math.min(xScale, yScale)`, and it will make ball near the edge get small. In duotone option, it applies the same logic, with different comparison method other than `Math.min`. I compare the lightness of the `xColor` and `yColor`, so it gets darker when ball moves toward the edge. 

The performance of motion value is great.

<AppleWatchDock />

## Cursor Tracking
In this example, `x` and `y` is motion value, but they are not linked with drag.They are updated by `onMouseMove` by calculating the distance between cursor and the pad (middle div). The `rotateX` and `rotateY` are new motion value transformed from `x` and `y`.

```js
const x = useMotionValue(width / 2)
const y = useMotionValue(height / 2)

const handleMove = (e) => {
    const rect = e.currentTarget.getBoundingClientRect()
    x.set(e.clientX - rect.left)
    y.set(e.clientY - rect.top)
}

const rotateX = useTransform(y, [0, height], [-45, 45])
const rotateY = useTransform(x, [0, width], [45, -45])

```

<CursorTrack />